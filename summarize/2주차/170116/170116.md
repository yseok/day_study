# 자바란?
 - [자바](https://ko.wikipedia.org/wiki/%EC%9E%90%EB%B0%94_(%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_%EC%96%B8%EC%96%B4)) (영어: Java, 문화어: 쟈바)는 썬 마이크로시스템즈의 제임스 고슬링(James Gosling)과 다른 연구원들이 개발한 객체 지향적 프로그래밍 언어.

 > 유닉스 기반의 배경을 가지고 있었기 때문에 문법적인 특성은 파스칼이 아닌 C++의 조상인 C 언어와 비슷하다.[14] 자바를 다른 컴파일언어와 구분짓는 가장 큰 특징은 컴파일된 코드가 플랫폼 독립적이라는 점이다. 자바 컴파일러는 자바 언어로 작성된 프로그램을 바이트코드라는 특수한 바이너리 형태로 변환한다. 바이트코드를 실행하기 위해서는 JVM(자바 가상 머신, Java Virtual Machine)이라는 특수한 가상 머신이 필요한데, 이 가상 머신은 자바 바이트코드를 어느 플랫폼에서나 동일한 형태로 실행시킨다. 때문에 자바로 개발된 프로그램은 CPU나 운영 체제의 종류에 관계없이 JVM을 설치할 수 있는 시스템에서는 어디서나 실행할 수 있다.

# (.class)파일의 Magic Number
 - 파일이 어떤 타입인지 고유의 식별자를 그 안에 가지고 있는 것.

# (.class) JAVA Byte Code
 - 특정 하드웨어가 아닌 가상 컴퓨터에서 돌아가는 실행 프로그램을 위한 이진 표현법

 > 바이트코드 프로그램은 보통 한번에 하나의 명령어를 읽은 후 실행한다. 이러한 형태의 바이트코드 인터프리터는 높은 이식성을 갖는다. 또 다른 형태로서 실시간 번역기 또는 저스트 인 타임(just-in-time, JIT) 컴파일러라 불리는 시스템은 실행 중에 필요에 따라서 바이트코드를 기계어로 번역한다.

# JAVA파일의 Runtime 컴파일
 - JAVA는 VM을 통해 컴파일진행, 각 OS에 맞게 기계어 컴파일

 > JIT (just-in-time compilation) :  동적 번역(dynamic translation)이라고도 하는데, 프로그램을 실제 실행하는 시점에 기계어로 번역하는 컴파일 기법이다. 이 기법은 프로그램의 실행 속도를 빠르게 하기 위해 사용된다. 실행 시점에서 기계어 코드를 생성하면서 그 코드를 캐싱하여, 같은 함수가 여러 번 불릴 때 매번 기계어 코드를 생성하는 것을 방지한다.

 > AOT (ahead-of-time compile) : 목표 시스템의 기계어와 무관하게 중간 언어 형태로 배포된 후 목표 시스템에서 인터프리터나 JIT 컴파일 등 기계어 번역을 통해 실행되는 중간 언어를 미리 목표 시스템에 맞는 기계어로 번역하는 방식. 


# JAVA의 실행과정

![자바실행과정]()

 > Java Source(.java)를 Byte Code(.class)로 변환하여 JVM을 통하여 실행된다.

# JAVA의 메모리 구조

![자바메모리구조]()

 > 프로그램이 실행되면, JVM은 OS으로부터 이 프로그램이 필요로 하는 메모리를 할당받고, JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다.

 >> Heap Area (인스턴스를 위한 영역)
 • 인스턴스가 생성되는 메모리공간
 • JVM에 의한 메모리 공간의 인스턴스 정리 (Garbage Collection)이 이루어 지는 공간
 • 인스턴스의 할당은 프로그래머가, 소멸은 JVM이 담당
 • Garbage Collection의 탐색 효율성을 위해 Heap Area에 인스턴스를 할당, 정리 기준 : 참조변수에 의한 참조가 이루어지지 않는 인스턴스

***

# 코드 작성 규칙
 - 식별자

 > 클래스, 함수, 변수의 이름
 > 대소문자 구분.
 > 첫글자에 숫자를 사용할 수 없다.

 - [예약어]()
 > 이미 문법적인 용도로 사용되고 있기 때문에 식별자로 사용할 수 없는 단어

 - 기본 자료형

![기본자료형]()

 > **기본 자료형**
 >> 논리형 : boolean (1 bit)
 >> 문자형 : char(16 bit), byte(8 bit)
 >> 정수형 : short(16 bit), int(32 bit), long(64 bit)
 >> 실수형 : float(32 bit), double(64 bit)

 >>> String은 많이 쓰지이만 기본 자료형이 아니다.

# 문자형 Data타입의 적용
 - char = '', String = "" 구분 사용

 - 정수형 : byte, short, int, long

 > 데이터를 처리할때는 byte + byte라 하더라도 int로 변환하여 계산
 >> byte + byte = int
 >> short + short = int

 - 실수형 : float, double
 > 소수는 기본적으로 double형으로 인식

 - 소수점 연산 오류 원인

 > 1. 컴퓨터는 HW는 기본적으로 소수점인 0.1을 표현할 수 없다
 > 0과 1의 정수만 표현 가능한데, 소수점 표현을 위해 지수부와 가수부를 구분해서 표시하게 된다
 
 >> 지수가수 표기법

 >> a = 0.1515 *  10E1

 >> b = 0.55 * 10E-5

 >>>풀어쓰기

 >>>a = 1.515
 >>>b = 0.0000055

 >>> 지수가수 표기법으로 변경(가수에 할당된 자리수가 7자리일 경우)
 >>> a + b = 0.15150055 * 10E1 < 1.5150055 
	* 여기서 0.0000005의 오차가 발생한다.
 >>> 가수부가 3자리로 한정되면 아래와 같이 뒷자리가 절삭된다.
 >>> a + b = 0.152 * 10E1
 >>> // 지수 =  10의 몇승 같은표기

# 부동소수점 연산의 한계
 - 각 언어별 국제 코딩표준에서 정확한 수치 연산의 경우 부동소수점 연산을 하지 못하도록 규정하고 있다.정확한 계산에서 소수점연산을 사용하는건 JSF나 MISRA-C의 규칙에 위배된다. JSF AV C++을 비롯한 많은 코딩 퓨준에서는 부동 소수점 변수를 직접적으로 비교하지 못하도록 규정하고 있다.

# 자료형변환
 - JAVA에서는 계산 형태에 따라 자동으로 형을 변환해준다

 - 그 이외의 경우는 강제로 형을 변환해서 사용해야 한다. 경우에 따라 값의 정밀도를 잃을 수 있다.

 > 예) float -> int변환시 소수점 이하 버림

# 자료형 형변환(문자 <-> 숫자)
 - 숫자를 문자로 변경

 > int nu, = 2016;
 > String str = String.valueOf(num);

 > String str2 = num + "";

 - 문자를 숫자로 변경

 > String str = "2016";

# 연산자(Operators) 우선 순위
 
![연산자우선순위()
 
# 산술연산자
 - 산술연산자 : 사칙연산자(+,-,*,/), 나머지연산자(%), 쉬프트연산자(<<,>>,>>>)는 모두 두개의 피연산자를 취하는 이항연산자이며, 이항 연산자는 피연산자의 크기가 4 byte보다 작으면 4byte(int형)로 변환한 다음에 연산을 수행

# !(not) 연산자
 - 논리적 NOT의 의미를 가지는 단항 연산자.

# ~ (bit not)연산자
 - 비트 논리적 NOT의 의미를 가지는 단항 연산자이다.
값을 2진 bit로 변경하고 각 bit의 값을 1은 0으로, 0은 1로 바꾸어준다,

# 쉬프트 연산자.
-변수의 값을 2진 비트로 변경하고, 입력한 값만큼 비트를 이동시킨다.

 >> << 비트를 왼쪽으로 이동한다. 가장 오른쪽 비트는 0으로 채운다
	왼쪽으로 한번 쉬프트 할 때마다 값이 약 2배 증가한다.

 >> >> 오른쪽으로 한번 쉬프트 할때마다 값이 약 반으로 감소한다.
 >> >>> 연산자는 나누기 또는 곱하기 효과 보다는 비트 이동이 필요할 때 사용한다. 부호비트(가장왼쪽)에 0이 채워지므로 항상 양의 정수가 만들어진다.

# 관계 연산자
 - 두 항의 비교를 통해 true 와 false인 boolean값을 출력한다.


# 논리 연산자
 - 논리 연산(logical operation, logical connective) 혹은 불 연산(boolean operation)은 참, 거짓 두가지 원소(진리값으로 불림)만 존재하는 집합(환으로 불림)에서의 연산이다.

 > 논리합(OR, ∨), 논리곱(AND, ∧), 부정(NOT, ~/¬), 배타적 논리합(XOR, ⊕), 명제, 동치 등이 있다.

# 비트 논리 연산자
 ### 한 개 혹은 두 개의 이진수에 대해 비트 단위로 적용되는 연산

 - AND :a&b 두 값의 각 자릿수를 비교해 두 값 모두에 1이 있을때에만 1을, 나머지 경우에는 0을 계산

 > 0101 & 0011 = 0001

 - OR : a|b 두 값의 각 자릿수를 비교해, 둘 중 하나라도 1이 있다면 1을, 아니면 0을 계산

 > 0101 | 0011 = 0111

 - NOT : ~a 각 자릿수의 값을 반대로 바꾸는 연산

 > ~ 0111 = 1000

 - XOR : a^b 두 값의 각 자릿수를 비교해,값이 0으로 같으면 0, 값이 1로 같으면 0, 다르면 1을 계산

 > 0101 ^ 0011 = 0110

# 3항 연산자
 - 삼항연산자란 삼항연산자 조건연산자 라고도한다. 연산자 ?: 는 결국에 if - else구조
 
 > 형식 : (boolean) ? c(true일경우) : d(false일경우)
 >> ex) pass = (국어 > 국어_커트라인)?true : false;

# 증감 연산자
 -  피연산자로부터 더하거나 빼는 등 단항 연산을 위한 연산자
 - ++,--

 > 값을 1씩 더하고 빼는 연산자이다. 위치에 따라 결과가 달라진다

26.대입 연산자

![자바대입연산자]()

 > 대입 연산은 좌항의 표현으로 관리하는 변수에 설정하는 연산이다. 따라서 대입 연산의 좌항에는 상수가 올 수 없다. 또한 대입 연산은 우선 순위가 가장 낮은 연산이라는 것에 주의해야 한다.
 
 >> 단순 대입 연산 : 우측 표현식의 값을 좌항에 설정하는 연산. = 기호를 이용
 >> 복합 대입 연산 : 자기 자신과 우측 피연산자 사이에 특정 연산을 수행한 결과를 좌항에 설정하는 연산.  +=, *= 등 사용

***

# 자바의 제어문
 - 조건문 : 주어진 조건에 대해 분기를 한다
 - 반복문 : 조건에 따라 반복문 블록 안의 로직을 반복적으로 처리한다.
 - 예외처리문 : 예외가 발생했을때 처리한다.

## 조건문 if~ else
 - if : if문은 조건문이다. 즉, 만약 주어진 조건에 true이면 실행되고 false면 실행하지 않는다.
 - else : else는 쓴 숫자가 if의 조건에 맞지 않을때 실행된다. 즉, 조건문의 조건이 false이면 실행되고 true면 실행하지 않는다.

## 조건문 switch ~ case
 - 조건문의 일종인데, 여러 개의 if~else 문을 대신하여 간결하게 작성할 때 사용하는 것.

 > switch문 다음의 괄호()에는 "i <= 0" 이런 식의 판단문이 들어갈 수는 없고, 정수형이나 문자형(char)의 숫자만 들어갈 수 있는 제약이 있다.

## 반복문 for

![for문]()

 - 형식 : for (변수 초기값; 변수의 값이 ~인 동안 계속; 변수의 변동값)의 형식으로 사용
 - for문 안의 for문을 여러번 중첩하여 사용할 수 있다.


## 반복문 while
 - while 문은 조건이 참일 동안 블럭 안의 로직을 반복 실행
 - do~while문은 로직을 한 번 실행 하고 조건을 실행한다.

## break
 - break는 switch 또는 반복문을 종료

## coutinue
 - continue 시 아래로직은 무시된다.
